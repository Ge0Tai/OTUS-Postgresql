### Домашнее задание № 7 (Блокировки PostgreSQL)

1. Подготовим к домашнему заданию новую БД - <b>otus_lock</b>.

Справочная информация о блокировках:

### pg_locks - (представление) текущие блокировки в БД
 - <b>relation</b>  
Блокировки отношений.

 - <b>transactionid</b> и <b>virtualxid</b>  
Блокировка номера транзакции (настоящего или виртуального). Каждая транзакция сама удерживает исключительную блокировку своего собственного номера, поэтому такие блокировки удобно использовать, когда нужно дождаться окончания другой транзакции.

 - <b>tuple</b>  
Блокировка версии строки. Используется в некоторых случаях для установки приоритета среди нескольких транзакций, ожидающих блокировку одной и той же строки.

 - <b>extend</b>  
Используется при добавлении страниц к файлу какого-либо отношения.

 - <b>object</b>  
Блокировка объектов, которые не являются отношениями (баз данных, схем, подписок и т. п.).

 - <b>page</b>  
Блокировка страницы, используется нечасто и только некоторыми типами индексов.

 - <b>advisory</b>  
Рекомендательная блокировка, устанавливается пользователем вручную.

#### Матрица совместимости блокировок:

![](pics/dz8/1_matrix_locks.PNG)

### pg_blocking_pids(<i>pid</i>) - (функция) кто блокирует
### log_lock_waits - (параметр)
### max_locks_per_transaction × max_connections - максимальное количество блокировок в системе

>Пул блокировок — общий для всех транзакций, то есть одна транзакция может захватить больше блокировок, чем max_locks_per_transaction: важно лишь, чтобы общее число блокировок в системе не превысило установленный предел. Пул создается при запуске, так что <b>изменение любого из двух указанных параметров требует перезагрузки сервера</b>.

2. Настроим параметры:

![](pics/dz8/1_set_params_deadlocks.PNG)

Создадим вью <b>v_locks</b>:

 `CREATE VIEW v_locks AS`  
 `SELECT pid,`  
       `locktype,`  
       `CASE locktype`  
         `WHEN 'relation' THEN relation::REGCLASS::text`  
         `WHEN 'virtualxid' THEN virtualxid::text`  
         `WHEN 'transactionid' THEN transactionid::text`  
         `WHEN 'tuple' THEN relation::REGCLASS::text||':'||tuple::text`  
       `END AS lockid,`  
       `mode,`  
       `granted`  
 `FROM pg_locks;`
 
 ![](pics/dz8/2_cr_view_locks.PNG)
 
 Обратимся к нашему вью и увидим следующие блокировки (для каждого сеанса, в данном случае, одинаковые, т.к. происходит только чтение и обращение к одним и тем же отношениям:

 ![](pics/dz8/2_sel_v_locks.PNG)
 
 Мы видим <b>pid</b> нашего процесса, который запросил 3 блокировки (2 блокировки на отношения - наше вью <b>v_locks</b> и таблицу <b>pg_locks</b> + 1 блокировка виртуального номера транзакции) в режиме чтения (<b>AccessShareLock</b>) и получил их - <b>granted</b> = <b>t</b><i>rue</i>
 
 Теперь начнём транзакцию и создадим таблицу <b>accounts</b>:

 `create table accounts(id integer, amount numeric);`  
 
 Эту таблицу мы не увидим в других сессиях (транзакция не закомичена), но увидим какие блокировки получены:

![](pics/dz8/2_cr_tbl_no_commit.PNG)

Видим, что по мимо 3-х вышеописанных блокировок, сеанс получил и удерживает (<b>granted t</b>) блокировку в режиме <b>AccessExlusiveLock</b> на созданную таблицу (<b>relation</b>) <b>accounts</b>. Кроме того, транзакция захватила себе блокировку типа <b>transactionid</b> - т.е. наша транзакция теперь имеет реальны (не виртуальный) <b>id</b> - <b>1610376</b>. 
```diff
- Про pg_toast не совсем понятно (возможно это связано с типом данных numeric)?
```

Теперь закоммитим нашу транзакцию (создания таблицы) и убедимся, что блокировки сняты и таблица появилась в базе:

![](pics/dz8/2_cr_tbl_commit.PNG)
   
3. Заполним таблицу данными:

 `INSERT INTO accounts VALUES (1,2000.00), (2,2000.00), (3,2000.00), (4,3000.00), (5,3500.00);`
 

